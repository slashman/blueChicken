<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>3D Cube Wall Dungeon (Phaser)</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
<script>
const config = {
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  backgroundColor: '#222',
  scene: {
    preload,
    create,
    update
  }
};

const game = new Phaser.Game(config);

let playerHP = 10;

const map = [
  [1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,1],
  [1,0,1,1,1,0,0,1],
  [1,0,1,0,0,0,1,1],
  [1,0,1,0,1,0,0,1],
  [1,0,0,0,1,0,0,1],
  [1,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1],
];

const relics = [
  { x: 1, y: 1, name: "Ancient Coin" },
  { x: 4, y: 3, name: "Silver Ring" },
  { x: 5, y: 5, name: "Mystic Gem" }
];

const monsters = [
  { x: 3, y: 2 },
  { x: 5, y: 3 },
  { x: 6, y: 5 }
];

let monsterTimer = 0;
const monsterInterval = 1000; // milliseconds

const DIRS = [
  { x: 0, y: -1 }, // North
  { x: 1, y: 0 },  // East
  { x: 0, y: 1 },  // South
  { x: -1, y: 0 }  // West
];

let player = {
  x: 1,
  y: 1,
  dir: 0,
  inventory: [] // Player's inventory
};

let keys;

function preload() {}

function create() {
  keys = this.input.keyboard.addKeys('W,A,S,D');
}

function update(time, delta) {
  handleInput();
  
  monsterTimer += delta;
  if (monsterTimer >= monsterInterval) {
    moveMonsters();
    monsterTimer = 0;
  }

  renderScene(this);
  renderInventory(this);
}

function handleInput() {
  if (Phaser.Input.Keyboard.JustDown(keys.W)) {
    movePlayer(0);
  }
  if (Phaser.Input.Keyboard.JustDown(keys.S)) {
    movePlayer(2);
  }
  if (Phaser.Input.Keyboard.JustDown(keys.A)) {
    player.dir = (player.dir + 3) % 4;
  }
  if (Phaser.Input.Keyboard.JustDown(keys.D)) {
    player.dir = (player.dir + 1) % 4;
  }
}

function movePlayer(directionIndex) {
  const dx = DIRS[player.dir].x;
  const dy = DIRS[player.dir].y;
  const nx = player.x + dx;
  const ny = player.y + dy;
  
  if (map[ny] && map[ny][nx] === 0) {
    player.x = nx;
    player.y = ny;

    // Check for relic pickup
    const relicIndex = relics.findIndex(r => r.x === player.x && r.y === player.y);
    if (relicIndex !== -1) {
      const relic = relics.splice(relicIndex, 1)[0]; // Remove the relic from the map
      player.inventory.push(relic); // Add to inventory
    }
  }
}

function moveMonsters() {
  monsters.forEach(monster => {
    const dx = player.x - monster.x;
    const dy = player.y - monster.y;
    const distance = Math.abs(dx) + Math.abs(dy);

    let stepX = 0;
    let stepY = 0;

    const isOccupied = (x, y) => {
      return monsters.some(m => m !== monster && m.x === x && m.y === y);
    };

    const tryRandomMove = () => {
      const dirs = Phaser.Utils.Array.Shuffle([
        [0, -1], [1, 0], [0, 1], [-1, 0]
      ]);
      for (const [dx, dy] of dirs) {
        const newX = monster.x + dx;
        const newY = monster.y + dy;
        if (
          map[newY][newX] !== 1 &&
          !(newX === player.x && newY === player.y) &&
          !isOccupied(newX, newY)
        ) {
          monster.x = newX;
          monster.y = newY;
          break;
        }
      }
    };

    if (distance <= 4) {
      // Move toward player or attack if adjacent
      if (Math.abs(dx) > Math.abs(dy)) {
        stepX = Math.sign(dx);
      } else {
        stepY = Math.sign(dy);
      }

      const newX = monster.x + stepX;
      const newY = monster.y + stepY;

      if (map[newY][newX] !== 1) {
        if (newX === player.x && newY === player.y) {
          // Attack player
          playerHP--;
          console.log(`The ${monster.name} hits you! HP: ${playerHP}`);
          if (playerHP <= 0) {
            console.log("You died!");
            // TODO: Handle game over
          }
        } else if (!isOccupied(newX, newY)) {
          monster.x = newX;
          monster.y = newY;
        } else {
          tryRandomMove();
        }
      } else {
        tryRandomMove();
      }
    } else {
      // Random walk
      tryRandomMove();
    }
  });
}

function renderScene(scene) {
  scene.children.removeAll();

  const baseX = 400;
  const baseY = 300;
  const depthSteps = 3;

  const isWall = (x, y) => map[y]?.[x] === 1;

  const forward = DIRS[player.dir];
  const left = DIRS[(player.dir + 3) % 4];
  const right = DIRS[(player.dir + 1) % 4];

  for (let d = depthSteps; d >= 0; d--) {
    const scale = 1 / (d === 0 ? 0.5 : d); // depth 0 is very close
    const wallW = 800 * scale * 0.5;
    const wallH = 600 * scale * 0.5;

    const prevScale = 1 / (d <= 1 ? 0.5 : d - 1);
    const prevWallW = 800 * prevScale * 0.5;
    const prevWallH = 600 * prevScale * 0.5;

    const cx = baseX;
    const cy = baseY;

    const floorTiles = [
      { dx: -1 }, { dx: 0 }, { dx: 1 },
    ];

    for (const tile of floorTiles) {
      const x0 = cx + tile.dx * wallW;
      const y0 = cy + wallH * 0.5;
      const x1 = cx + tile.dx * prevWallW;
      const y1 = cy + prevWallH * 0.5;

      const floorPoly = new Phaser.Geom.Polygon([
        x0 - wallW / 2, y0,
        x0 + wallW / 2, y0,
        x1 + prevWallW / 2, y1,
        x1 - prevWallW / 2, y1
      ]);

      const g = scene.add.graphics();
      g.fillStyle(0xaaaaaa, 0.4);
      g.lineStyle(2, 0x000000, 0.8);
      g.strokePoints(floorPoly.points, true);
      g.fillPoints(floorPoly.points, true);
    }

    const fx = player.x + forward.x * d;
    const fy = player.y + forward.y * d;

    const flx = fx + left.x;
    const fly = fy + left.y;
    const frx = fx + right.x;
    const fry = fy + right.y;

    const relicHere = relics.find(r => r.x === fx && r.y === fy);
    if (relicHere && !isWall(fx, fy)) {
      const g = scene.add.graphics();
      const radius = 16 * scale;
      g.fillStyle(0xffdd00, 1);
      g.lineStyle(2, 0x000000, 1);
      g.strokeCircle(cx, cy + wallH * 0.5 - 20 * scale, radius);
      g.fillCircle(cx, cy + wallH * 0.5 - 20 * scale, radius);
    }

    const monsterHere = monsters.find(m => m.x === fx && m.y === fy);
    if (monsterHere && !isWall(fx, fy)) {
      const g = scene.add.graphics();
      const radius = 18 * scale;
      g.fillStyle(0xff4444, 1);
      g.lineStyle(2, 0x000000, 1);
      g.strokeCircle(cx, cy + wallH * 0.5 - 60 * scale, radius);
      g.fillCircle(cx, cy + wallH * 0.5 - 60 * scale, radius);
    }

    // --- Front Wall ---
    if (isWall(fx, fy)) {
      const g = scene.add.graphics();
      g.fillStyle(0x8888ff, 1);
      g.lineStyle(2, 0x000000, 1);
      g.strokeRect(cx - wallW / 2, cy - wallH / 2, wallW, wallH);
      g.fillRect(cx - wallW / 2, cy - wallH / 2, wallW, wallH);
    }

    // --- Side Walls ---
    if (isWall(flx, fly)) {
      const g = scene.add.graphics();
      g.fillStyle(0x6666cc, 1);
      g.lineStyle(2, 0x000000, 1);
      g.strokeRect(cx - 1.5 * wallW, cy - wallH / 2, wallW, wallH);
      g.fillRect(cx - 1.5 * wallW, cy - wallH / 2, wallW, wallH);
    }

    if (isWall(frx, fry)) {
      const g = scene.add.graphics();
      g.fillStyle(0x6666cc, 1);
      g.lineStyle(2, 0x000000, 1);
      g.strokeRect(cx + 0.5 * wallW, cy - wallH / 2, wallW, wallH);
      g.fillRect(cx + 0.5 * wallW, cy - wallH / 2, wallW, wallH);
    }

    const prevFx = player.x + forward.x * (d - 1);
    const prevFy = player.y + forward.y * (d - 1);

    const sideLeftX = prevFx + left.x;
    const sideLeftY = prevFy + left.y;
    const sideRightX = prevFx + right.x;
    const sideRightY = prevFy + right.y;

    if (isWall(sideLeftX, sideLeftY)) {
      const poly = new Phaser.Geom.Polygon([
        cx - prevWallW / 2, cy - prevWallH / 2,
        cx - prevWallW / 2, cy + prevWallH / 2,
        cx - wallW / 2,     cy + wallH / 2,
        cx - wallW / 2,     cy - wallH / 2
      ]);
      const g = scene.add.graphics();
      g.fillStyle(0x44aa44, 1);
      g.lineStyle(2, 0x000000, 1);
      g.strokePoints(poly.points, true);
      g.fillPoints(poly.points, true);
    }

    if (isWall(sideRightX, sideRightY)) {
      const poly = new Phaser.Geom.Polygon([
        cx + prevWallW / 2, cy - prevWallH / 2,
        cx + prevWallW / 2, cy + prevWallH / 2,
        cx + wallW / 2,     cy + wallH / 2,
        cx + wallW / 2,     cy - wallH / 2
      ]);
      const g = scene.add.graphics();
      g.fillStyle(0x4444aa, 1);
      g.lineStyle(2, 0x000000, 1);
      g.strokePoints(poly.points, true);
      g.fillPoints(poly.points, true);
    }
  }

  drawMinimap(scene);
}

function renderInventory(scene) {
  const offsetX = 16;
  const offsetY = 16;
  const lineHeight = 24;
  scene.add.text(offsetX, offsetY, "Inventory:", { font: '16px Arial', color: '#fff' });

  player.inventory.forEach((relic, index) => {
    scene.add.text(offsetX, offsetY + (index + 1) * lineHeight, relic.name, { font: '14px Arial', color: '#fff' });
  });
}

function drawMinimap(scene) {
  const minimapSize = 128;
  const tileSize = minimapSize / map.length;
  const offsetX = 16;
  const offsetY = config.height - minimapSize - 16;

  const g = scene.add.graphics();
  g.fillStyle(0x000000, 0.6);
  g.fillRect(offsetX - 4, offsetY - 4, minimapSize + 8, minimapSize + 8);

  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[y].length; x++) {
      g.fillStyle(map[y][x] === 1 ? 0xffffff : 0x222222);
      g.fillRect(offsetX + x * tileSize, offsetY + y * tileSize, tileSize, tileSize);
    }
  }

  // Monsters
  for (const m of monsters) {
    g.fillStyle(0xff4444);
    g.fillCircle(
      offsetX + m.x * tileSize + tileSize / 2,
      offsetY + m.y * tileSize + tileSize / 2,
      tileSize / 4
    );
  }

  // Player
  g.fillStyle(0xff0000);
  g.fillCircle(
    offsetX + player.x * tileSize + tileSize / 2,
    offsetY + player.y * tileSize + tileSize / 2,
    tileSize / 3
  );

  // Direction
  const dx = DIRS[player.dir].x * tileSize * 0.5;
  const dy = DIRS[player.dir].y * tileSize * 0.5;
  g.lineStyle(2, 0xff0000);
  g.beginPath();
  g.moveTo(
    offsetX + player.x * tileSize + tileSize / 2,
    offsetY + player.y * tileSize + tileSize / 2
  );
  g.lineTo(
    offsetX + player.x * tileSize + tileSize / 2 + dx,
    offsetY + player.y * tileSize + tileSize / 2 + dy
  );
  g.strokePath();
}

</script>
</body>
</html>
