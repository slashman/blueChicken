<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>3D Cube Wall Dungeon (Phaser)</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
<script>
const config = {
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  backgroundColor: '#222',
  scene: {
    preload,
    create,
    update
  }
};

const game = new Phaser.Game(config);

const map = [
  [1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,1],
  [1,0,1,1,1,0,0,1],
  [1,0,1,0,1,0,1,1],
  [1,0,1,0,1,0,0,1],
  [1,0,0,0,1,1,0,1],
  [1,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1],
];

const DIRS = [
  { x: 0, y: -1 }, // North
  { x: 1, y: 0 },  // East
  { x: 0, y: 1 },  // South
  { x: -1, y: 0 }  // West
];

let player = {
  x: 1,
  y: 1,
  dir: 0
};

let keys;

function preload() {}

function create() {
  keys = this.input.keyboard.addKeys('W,A,S,D');
}

function update() {
  handleInput();
  renderScene(this);
}

function handleInput() {
  if (Phaser.Input.Keyboard.JustDown(keys.W)) {
    const dx = DIRS[player.dir].x;
    const dy = DIRS[player.dir].y;
    const nx = player.x + dx;
    const ny = player.y + dy;
    if (map[ny][nx] === 0) {
      player.x = nx;
      player.y = ny;
    }
  }
  if (Phaser.Input.Keyboard.JustDown(keys.S)) {
    const dx = DIRS[player.dir].x;
    const dy = DIRS[player.dir].y;
    const nx = player.x - dx;
    const ny = player.y - dy;
    if (map[ny][nx] === 0) {
      player.x = nx;
      player.y = ny;
    }
  }
  if (Phaser.Input.Keyboard.JustDown(keys.A)) {
    player.dir = (player.dir + 3) % 4;
  }
  if (Phaser.Input.Keyboard.JustDown(keys.D)) {
    player.dir = (player.dir + 1) % 4;
  }
}

function renderScene(scene) {
  scene.children.removeAll();

  const baseX = 400;
  const baseY = 300;
  const depthSteps = 3;

  const isWall = (x, y) => map[y]?.[x] === 1;

  const forward = DIRS[player.dir];
  const left = DIRS[(player.dir + 3) % 4];
  const right = DIRS[(player.dir + 1) % 4];

  for (let d = depthSteps; d >= 0; d--) {
    const scale = 1 / (d === 0 ? 0.5 : d); // depth 0 is very close
    const wallW = 800 * scale * 0.5;
    const wallH = 600 * scale * 0.5;

    const prevScale = 1 / (d <= 1 ? 0.5 : d - 1);
    const prevWallW = 800 * prevScale * 0.5;
    const prevWallH = 600 * prevScale * 0.5;

    const cx = baseX;
    const cy = baseY; // âœ… Keep fixed to avoid stair-stepping

    // Floor tiles with labels
    const floorTiles = [
      { dx: -1, label: `${d}-L` },
      { dx: 0, label: `${d}` },
      { dx: 1, label: `${d}-R` },
    ];

    for (const tile of floorTiles) {
      const x0 = cx + tile.dx * wallW;
      const y0 = cy + wallH * 0.5;
      const x1 = cx + tile.dx * prevWallW;
      const y1 = cy + prevWallH * 0.5;

      const floorPoly = new Phaser.Geom.Polygon([
        x0 - wallW / 2, y0,
        x0 + wallW / 2, y0,
        x1 + prevWallW / 2, y1,
        x1 - prevWallW / 2, y1
      ]);

      const g = scene.add.graphics();
      g.fillStyle(0xaaaaaa, 0.4);
      g.lineStyle(2, 0x000000, 0.8);
      g.strokePoints(floorPoly.points, true);
      g.fillPoints(floorPoly.points, true);

      scene.add.text(x0, y0 - 12, tile.label, {
        font: `${14 * scale}px Arial`,
        color: "#000",
      }).setOrigin(0.5, 1);
    }

    const fx = player.x + forward.x * d;
    const fy = player.y + forward.y * d;
    const flx = fx + left.x;
    const fly = fy + left.y;
    const frx = fx + right.x;
    const fry = fy + right.y;

    if (isWall(fx, fy)) {
      const g = scene.add.graphics();
      g.fillStyle(0x8888ff, 1);
      g.lineStyle(2, 0x000000, 1);
      g.strokeRect(cx - wallW / 2, cy - wallH / 2, wallW, wallH);
      g.fillRect(cx - wallW / 2, cy - wallH / 2, wallW, wallH);
    }

    if (isWall(flx, fly)) {
      const g = scene.add.graphics();
      g.fillStyle(0x6666cc, 1);
      g.lineStyle(2, 0x000000, 1);
      g.strokeRect(cx - 1.5 * wallW, cy - wallH / 2, wallW, wallH);
      g.fillRect(cx - 1.5 * wallW, cy - wallH / 2, wallW, wallH);
    }

    if (isWall(frx, fry)) {
      const g = scene.add.graphics();
      g.fillStyle(0x6666cc, 1);
      g.lineStyle(2, 0x000000, 1);
      g.strokeRect(cx + 0.5 * wallW, cy - wallH / 2, wallW, wallH);
      g.fillRect(cx + 0.5 * wallW, cy - wallH / 2, wallW, wallH);
    }

    const prevFx = player.x + forward.x * (d - 1);
    const prevFy = player.y + forward.y * (d - 1);

    const sideLeftX = prevFx + left.x;
    const sideLeftY = prevFy + left.y;
    const sideRightX = prevFx + right.x;
    const sideRightY = prevFy + right.y;

    const wallLeft = isWall(sideLeftX, sideLeftY);
    const wallRight = isWall(sideRightX, sideRightY);

    if (wallLeft) {
      const poly = new Phaser.Geom.Polygon([
        cx - prevWallW / 2, cy - prevWallH / 2,
        cx - prevWallW / 2, cy + prevWallH / 2,
        cx - wallW / 2,     cy + wallH / 2,
        cx - wallW / 2,     cy - wallH / 2
      ]);
      const g = scene.add.graphics();
      g.fillStyle(0x44aa44, 1);
      g.lineStyle(2, 0x000000, 1);
      g.strokePoints(poly.points, true);
      g.fillPoints(poly.points, true);
    }

    if (wallRight) {
      const poly = new Phaser.Geom.Polygon([
        cx + prevWallW / 2, cy - prevWallH / 2,
        cx + prevWallW / 2, cy + prevWallH / 2,
        cx + wallW / 2,     cy + wallH / 2,
        cx + wallW / 2,     cy - wallH / 2
      ]);
      const g = scene.add.graphics();
      g.fillStyle(0x4444aa, 1);
      g.lineStyle(2, 0x000000, 1);
      g.strokePoints(poly.points, true);
      g.fillPoints(poly.points, true);
    }
  }

  drawMinimap(scene);
}

function drawMinimap(scene) {
  const minimapSize = 128;
  const tileSize = minimapSize / map.length;
  const offsetX = 16;
  const offsetY = config.height - minimapSize - 16;

  const g = scene.add.graphics();
  g.fillStyle(0x000000, 0.6);
  g.fillRect(offsetX - 4, offsetY - 4, minimapSize + 8, minimapSize + 8);

  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[y].length; x++) {
      g.fillStyle(map[y][x] === 1 ? 0xffffff : 0x222222);
      g.fillRect(offsetX + x * tileSize, offsetY + y * tileSize, tileSize, tileSize);
    }
  }

  // Player
  g.fillStyle(0xff0000);
  g.fillCircle(
    offsetX + player.x * tileSize + tileSize / 2,
    offsetY + player.y * tileSize + tileSize / 2,
    tileSize / 3
  );

  // Direction
  const dx = DIRS[player.dir].x * tileSize * 0.5;
  const dy = DIRS[player.dir].y * tileSize * 0.5;
  g.lineStyle(2, 0xff0000);
  g.beginPath();
  g.moveTo(
    offsetX + player.x * tileSize + tileSize / 2,
    offsetY + player.y * tileSize + tileSize / 2
  );
  g.lineTo(
    offsetX + player.x * tileSize + tileSize / 2 + dx,
    offsetY + player.y * tileSize + tileSize / 2 + dy
  );
  g.strokePath();
}



</script>
</body>
</html>
